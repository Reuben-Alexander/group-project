import {
  debounce,
  init_debounce
} from "./chunk-RDN3BZIR.js";
import {
  Backdrop_default
} from "./chunk-Z7AWYLDM.js";
import {
  Modal_default,
  getTransitionProps,
  reflow
} from "./chunk-EVOBOUC3.js";
import {
  useTheme
} from "./chunk-7E5QOVTT.js";
import {
  Transition_default
} from "./chunk-ZFVKR5UR.js";
import {
  init_useForkRef,
  useForkRef
} from "./chunk-C4J4MZA3.js";
import {
  require_react_dom
} from "./chunk-BO6Y6WZ2.js";
import {
  capitalize,
  init_capitalize
} from "./chunk-IANXW26V.js";
import {
  Paper_default
} from "./chunk-SOSLEC7M.js";
import {
  duration,
  init_transitions,
  init_withStyles,
  withStyles_default
} from "./chunk-3OKXD5MC.js";
import {
  _extends,
  _objectWithoutProperties,
  clsx_m_default,
  elementAcceptingRef_default,
  init_clsx_m,
  init_esm,
  init_extends,
  init_objectWithoutProperties
} from "./chunk-7RGT4SEV.js";
import {
  require_prop_types
} from "./chunk-4EGKYBNQ.js";
import {
  require_react
} from "./chunk-KQPGYOHB.js";
import {
  __toESM
} from "./chunk-V4OQ3NZ2.js";

// node_modules/@material-ui/core/esm/Drawer/Drawer.js
init_extends();
init_objectWithoutProperties();
var React2 = __toESM(require_react());
var import_prop_types2 = __toESM(require_prop_types());
init_clsx_m();
init_withStyles();

// node_modules/@material-ui/core/esm/Slide/Slide.js
init_extends();
init_objectWithoutProperties();
var React = __toESM(require_react());
var import_prop_types = __toESM(require_prop_types());
var ReactDOM = __toESM(require_react_dom());
init_debounce();
init_esm();
init_useForkRef();
init_transitions();
function getTranslateValue(direction, node) {
  var rect = node.getBoundingClientRect();
  var transform;
  if (node.fakeTransform) {
    transform = node.fakeTransform;
  } else {
    var computedStyle = window.getComputedStyle(node);
    transform = computedStyle.getPropertyValue("-webkit-transform") || computedStyle.getPropertyValue("transform");
  }
  var offsetX = 0;
  var offsetY = 0;
  if (transform && transform !== "none" && typeof transform === "string") {
    var transformValues = transform.split("(")[1].split(")")[0].split(",");
    offsetX = parseInt(transformValues[4], 10);
    offsetY = parseInt(transformValues[5], 10);
  }
  if (direction === "left") {
    return "translateX(".concat(window.innerWidth, "px) translateX(").concat(offsetX - rect.left, "px)");
  }
  if (direction === "right") {
    return "translateX(-".concat(rect.left + rect.width - offsetX, "px)");
  }
  if (direction === "up") {
    return "translateY(".concat(window.innerHeight, "px) translateY(").concat(offsetY - rect.top, "px)");
  }
  return "translateY(-".concat(rect.top + rect.height - offsetY, "px)");
}
function setTranslateValue(direction, node) {
  var transform = getTranslateValue(direction, node);
  if (transform) {
    node.style.webkitTransform = transform;
    node.style.transform = transform;
  }
}
var defaultTimeout = {
  enter: duration.enteringScreen,
  exit: duration.leavingScreen
};
var Slide = React.forwardRef(function Slide2(props, ref) {
  var children = props.children, _props$direction = props.direction, direction = _props$direction === void 0 ? "down" : _props$direction, inProp = props.in, onEnter = props.onEnter, onEntered = props.onEntered, onEntering = props.onEntering, onExit = props.onExit, onExited = props.onExited, onExiting = props.onExiting, style = props.style, _props$timeout = props.timeout, timeout = _props$timeout === void 0 ? defaultTimeout : _props$timeout, _props$TransitionComp = props.TransitionComponent, TransitionComponent = _props$TransitionComp === void 0 ? Transition_default : _props$TransitionComp, other = _objectWithoutProperties(props, ["children", "direction", "in", "onEnter", "onEntered", "onEntering", "onExit", "onExited", "onExiting", "style", "timeout", "TransitionComponent"]);
  var theme = useTheme();
  var childrenRef = React.useRef(null);
  var handleOwnRef = React.useCallback(function(instance) {
    childrenRef.current = ReactDOM.findDOMNode(instance);
  }, []);
  var handleRefIntermediary = useForkRef(children.ref, handleOwnRef);
  var handleRef = useForkRef(handleRefIntermediary, ref);
  var normalizedTransitionCallback = function normalizedTransitionCallback2(callback) {
    return function(isAppearing) {
      if (callback) {
        if (isAppearing === void 0) {
          callback(childrenRef.current);
        } else {
          callback(childrenRef.current, isAppearing);
        }
      }
    };
  };
  var handleEnter = normalizedTransitionCallback(function(node, isAppearing) {
    setTranslateValue(direction, node);
    reflow(node);
    if (onEnter) {
      onEnter(node, isAppearing);
    }
  });
  var handleEntering = normalizedTransitionCallback(function(node, isAppearing) {
    var transitionProps = getTransitionProps({
      timeout,
      style
    }, {
      mode: "enter"
    });
    node.style.webkitTransition = theme.transitions.create("-webkit-transform", _extends({}, transitionProps, {
      easing: theme.transitions.easing.easeOut
    }));
    node.style.transition = theme.transitions.create("transform", _extends({}, transitionProps, {
      easing: theme.transitions.easing.easeOut
    }));
    node.style.webkitTransform = "none";
    node.style.transform = "none";
    if (onEntering) {
      onEntering(node, isAppearing);
    }
  });
  var handleEntered = normalizedTransitionCallback(onEntered);
  var handleExiting = normalizedTransitionCallback(onExiting);
  var handleExit = normalizedTransitionCallback(function(node) {
    var transitionProps = getTransitionProps({
      timeout,
      style
    }, {
      mode: "exit"
    });
    node.style.webkitTransition = theme.transitions.create("-webkit-transform", _extends({}, transitionProps, {
      easing: theme.transitions.easing.sharp
    }));
    node.style.transition = theme.transitions.create("transform", _extends({}, transitionProps, {
      easing: theme.transitions.easing.sharp
    }));
    setTranslateValue(direction, node);
    if (onExit) {
      onExit(node);
    }
  });
  var handleExited = normalizedTransitionCallback(function(node) {
    node.style.webkitTransition = "";
    node.style.transition = "";
    if (onExited) {
      onExited(node);
    }
  });
  var updatePosition = React.useCallback(function() {
    if (childrenRef.current) {
      setTranslateValue(direction, childrenRef.current);
    }
  }, [direction]);
  React.useEffect(function() {
    if (inProp || direction === "down" || direction === "right") {
      return void 0;
    }
    var handleResize = debounce(function() {
      if (childrenRef.current) {
        setTranslateValue(direction, childrenRef.current);
      }
    });
    window.addEventListener("resize", handleResize);
    return function() {
      handleResize.clear();
      window.removeEventListener("resize", handleResize);
    };
  }, [direction, inProp]);
  React.useEffect(function() {
    if (!inProp) {
      updatePosition();
    }
  }, [inProp, updatePosition]);
  return React.createElement(TransitionComponent, _extends({
    nodeRef: childrenRef,
    onEnter: handleEnter,
    onEntered: handleEntered,
    onEntering: handleEntering,
    onExit: handleExit,
    onExited: handleExited,
    onExiting: handleExiting,
    appear: true,
    in: inProp,
    timeout
  }, other), function(state, childProps) {
    return React.cloneElement(children, _extends({
      ref: handleRef,
      style: _extends({
        visibility: state === "exited" && !inProp ? "hidden" : void 0
      }, style, children.props.style)
    }, childProps));
  });
});
true ? Slide.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // |     To update them edit the d.ts file and run "yarn proptypes"     |
  // ----------------------------------------------------------------------
  /**
   * A single child content element.
   */
  children: elementAcceptingRef_default,
  /**
   * Direction the child node will enter from.
   */
  direction: import_prop_types.default.oneOf(["down", "left", "right", "up"]),
  /**
   * If `true`, show the component; triggers the enter or exit animation.
   */
  in: import_prop_types.default.bool,
  /**
   * @ignore
   */
  onEnter: import_prop_types.default.func,
  /**
   * @ignore
   */
  onEntered: import_prop_types.default.func,
  /**
   * @ignore
   */
  onEntering: import_prop_types.default.func,
  /**
   * @ignore
   */
  onExit: import_prop_types.default.func,
  /**
   * @ignore
   */
  onExited: import_prop_types.default.func,
  /**
   * @ignore
   */
  onExiting: import_prop_types.default.func,
  /**
   * @ignore
   */
  style: import_prop_types.default.object,
  /**
   * The duration for the transition, in milliseconds.
   * You may specify a single timeout for all transitions, or individually with an object.
   */
  timeout: import_prop_types.default.oneOfType([import_prop_types.default.number, import_prop_types.default.shape({
    appear: import_prop_types.default.number,
    enter: import_prop_types.default.number,
    exit: import_prop_types.default.number
  })])
} : void 0;
var Slide_default = Slide;

// node_modules/@material-ui/core/esm/Drawer/Drawer.js
init_capitalize();
init_transitions();
var styles = function styles2(theme) {
  return {
    /* Styles applied to the root element. */
    root: {},
    /* Styles applied to the root element if `variant="permanent or persistent"`. */
    docked: {
      flex: "0 0 auto"
    },
    /* Styles applied to the `Paper` component. */
    paper: {
      overflowY: "auto",
      display: "flex",
      flexDirection: "column",
      height: "100%",
      flex: "1 0 auto",
      zIndex: theme.zIndex.drawer,
      WebkitOverflowScrolling: "touch",
      // Add iOS momentum scrolling.
      // temporary style
      position: "fixed",
      top: 0,
      // We disable the focus ring for mouse, touch and keyboard users.
      // At some point, it would be better to keep it for keyboard users.
      // :focus-ring CSS pseudo-class will help.
      outline: 0
    },
    /* Styles applied to the `Paper` component if `anchor="left"`. */
    paperAnchorLeft: {
      left: 0,
      right: "auto"
    },
    /* Styles applied to the `Paper` component if `anchor="right"`. */
    paperAnchorRight: {
      left: "auto",
      right: 0
    },
    /* Styles applied to the `Paper` component if `anchor="top"`. */
    paperAnchorTop: {
      top: 0,
      left: 0,
      bottom: "auto",
      right: 0,
      height: "auto",
      maxHeight: "100%"
    },
    /* Styles applied to the `Paper` component if `anchor="bottom"`. */
    paperAnchorBottom: {
      top: "auto",
      left: 0,
      bottom: 0,
      right: 0,
      height: "auto",
      maxHeight: "100%"
    },
    /* Styles applied to the `Paper` component if `anchor="left"` and `variant` is not "temporary". */
    paperAnchorDockedLeft: {
      borderRight: "1px solid ".concat(theme.palette.divider)
    },
    /* Styles applied to the `Paper` component if `anchor="top"` and `variant` is not "temporary". */
    paperAnchorDockedTop: {
      borderBottom: "1px solid ".concat(theme.palette.divider)
    },
    /* Styles applied to the `Paper` component if `anchor="right"` and `variant` is not "temporary". */
    paperAnchorDockedRight: {
      borderLeft: "1px solid ".concat(theme.palette.divider)
    },
    /* Styles applied to the `Paper` component if `anchor="bottom"` and `variant` is not "temporary". */
    paperAnchorDockedBottom: {
      borderTop: "1px solid ".concat(theme.palette.divider)
    },
    /* Styles applied to the `Modal` component. */
    modal: {}
  };
};
var oppositeDirection = {
  left: "right",
  right: "left",
  top: "down",
  bottom: "up"
};
function isHorizontal(anchor) {
  return ["left", "right"].indexOf(anchor) !== -1;
}
function getAnchor(theme, anchor) {
  return theme.direction === "rtl" && isHorizontal(anchor) ? oppositeDirection[anchor] : anchor;
}
var defaultTransitionDuration = {
  enter: duration.enteringScreen,
  exit: duration.leavingScreen
};
var Drawer = React2.forwardRef(function Drawer2(props, ref) {
  var _props$anchor = props.anchor, anchorProp = _props$anchor === void 0 ? "left" : _props$anchor, BackdropProps = props.BackdropProps, children = props.children, classes = props.classes, className = props.className, _props$elevation = props.elevation, elevation = _props$elevation === void 0 ? 16 : _props$elevation, _props$ModalProps = props.ModalProps;
  _props$ModalProps = _props$ModalProps === void 0 ? {} : _props$ModalProps;
  var BackdropPropsProp = _props$ModalProps.BackdropProps, ModalProps = _objectWithoutProperties(_props$ModalProps, ["BackdropProps"]), onClose = props.onClose, _props$open = props.open, open = _props$open === void 0 ? false : _props$open, _props$PaperProps = props.PaperProps, PaperProps = _props$PaperProps === void 0 ? {} : _props$PaperProps, SlideProps = props.SlideProps, _props$TransitionComp = props.TransitionComponent, TransitionComponent = _props$TransitionComp === void 0 ? Slide_default : _props$TransitionComp, _props$transitionDura = props.transitionDuration, transitionDuration = _props$transitionDura === void 0 ? defaultTransitionDuration : _props$transitionDura, _props$variant = props.variant, variant = _props$variant === void 0 ? "temporary" : _props$variant, other = _objectWithoutProperties(props, ["anchor", "BackdropProps", "children", "classes", "className", "elevation", "ModalProps", "onClose", "open", "PaperProps", "SlideProps", "TransitionComponent", "transitionDuration", "variant"]);
  var theme = useTheme();
  var mounted = React2.useRef(false);
  React2.useEffect(function() {
    mounted.current = true;
  }, []);
  var anchor = getAnchor(theme, anchorProp);
  var drawer = React2.createElement(Paper_default, _extends({
    elevation: variant === "temporary" ? elevation : 0,
    square: true
  }, PaperProps, {
    className: clsx_m_default(classes.paper, classes["paperAnchor".concat(capitalize(anchor))], PaperProps.className, variant !== "temporary" && classes["paperAnchorDocked".concat(capitalize(anchor))])
  }), children);
  if (variant === "permanent") {
    return React2.createElement("div", _extends({
      className: clsx_m_default(classes.root, classes.docked, className),
      ref
    }, other), drawer);
  }
  var slidingDrawer = React2.createElement(TransitionComponent, _extends({
    in: open,
    direction: oppositeDirection[anchor],
    timeout: transitionDuration,
    appear: mounted.current
  }, SlideProps), drawer);
  if (variant === "persistent") {
    return React2.createElement("div", _extends({
      className: clsx_m_default(classes.root, classes.docked, className),
      ref
    }, other), slidingDrawer);
  }
  return React2.createElement(Modal_default, _extends({
    BackdropProps: _extends({}, BackdropProps, BackdropPropsProp, {
      transitionDuration
    }),
    BackdropComponent: Backdrop_default,
    className: clsx_m_default(classes.root, classes.modal, className),
    open,
    onClose,
    ref
  }, other, ModalProps), slidingDrawer);
});
true ? Drawer.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // |     To update them edit the d.ts file and run "yarn proptypes"     |
  // ----------------------------------------------------------------------
  /**
   * Side from which the drawer will appear.
   */
  anchor: import_prop_types2.default.oneOf(["bottom", "left", "right", "top"]),
  /**
   * @ignore
   */
  BackdropProps: import_prop_types2.default.object,
  /**
   * The contents of the drawer.
   */
  children: import_prop_types2.default.node,
  /**
   * Override or extend the styles applied to the component.
   * See [CSS API](#css) below for more details.
   */
  classes: import_prop_types2.default.object,
  /**
   * @ignore
   */
  className: import_prop_types2.default.string,
  /**
   * The elevation of the drawer.
   */
  elevation: import_prop_types2.default.number,
  /**
   * Props applied to the [`Modal`](/api/modal/) element.
   */
  ModalProps: import_prop_types2.default.object,
  /**
   * Callback fired when the component requests to be closed.
   *
   * @param {object} event The event source of the callback.
   */
  onClose: import_prop_types2.default.func,
  /**
   * If `true`, the drawer is open.
   */
  open: import_prop_types2.default.bool,
  /**
   * Props applied to the [`Paper`](/api/paper/) element.
   */
  PaperProps: import_prop_types2.default.object,
  /**
   * Props applied to the [`Slide`](/api/slide/) element.
   */
  SlideProps: import_prop_types2.default.object,
  /**
   * The duration for the transition, in milliseconds.
   * You may specify a single timeout for all transitions, or individually with an object.
   */
  transitionDuration: import_prop_types2.default.oneOfType([import_prop_types2.default.number, import_prop_types2.default.shape({
    appear: import_prop_types2.default.number,
    enter: import_prop_types2.default.number,
    exit: import_prop_types2.default.number
  })]),
  /**
   * The variant to use.
   */
  variant: import_prop_types2.default.oneOf(["permanent", "persistent", "temporary"])
} : void 0;
var Drawer_default = withStyles_default(styles, {
  name: "MuiDrawer",
  flip: false
})(Drawer);

export {
  Slide_default,
  isHorizontal,
  getAnchor,
  Drawer_default
};
//# sourceMappingURL=chunk-7WDKXEVN.js.map
